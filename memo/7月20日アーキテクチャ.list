int a=3;
float f=3.14f;

C/C++/C#/Java
※静的型付け言語
宣言時に型が決定したら基本的には型を変えられない

Python/Javascript/Lua/Ruby
※動的型付け言語
代入時に型が決まる

Cylista Engine
(Cygames)
ゲーム部分をC++&DX
とツール部分をpythonでかいて、描画部分だけを
共有して、あたかもUE4とかUnityみたいに
ツール上でゲームが動いてるように見せている

C#のほうは分社化しました。
→cysharpという会社ができました。
Unityとか、ゲーム用ツールとかを作る

ツール用の言語
C#/Python


静的型付け言語においては、宣言時に型を書くのが
一般的でした。

ところが、
int a=3;
float f=3.14f;
のような場合、右辺値を代入して初期化する以上
型は「右辺値を見ればわかるんじゃね？」

→宣言時に右辺値が決定している場合はautoで宣言すると
右辺値を見て、自動で型を決定してくれる
※あくまでもC++は静的型付け言語なので、１度型が
決定すると変更できません

「範囲for文」「ラムダ式」を使うときに非常に楽になります。

bool Function(){
	return rand()%=0;
}

auto flg=Fnction();
って書くと、当然flgの型はboolになる

char c;
auto d=c;
これもdの型はcharになる

配列、コンテナ(vector,list,map)をまとめて
「コレクション」という

範囲for文は、このコレクションを全部処理するfor文
です。もともとstd::for_eachっていうものがあって
それをもうちょっと使いやすくしたもの。

for(型　変数X : コレクション){

}

C++11以降の便利な文法
auto
範囲for文
ラムダ式

C++以降のSTL周りの便利なもの
#include<memory>
shared_ptr<型>
unique_ptr<型>
weak_ptr<型>
スマートポインタの使い分け

#include<thread>
とか…スレッドに関しては、どうしても必要なところ
に限定して使ったほうがいい

意外とスレッド使ったからと言って必ずしも
早くなりません。結局バグ防止のために強調させるときに
町が発せして、早くならない
→スーパーハッカーが使うと超早くなる。

例えば裏読み(別スレッドでロードする)とかなら
もともと裏読みようの仕組みがAPIで用意されてることが
多いため、そっち使ったほうがいいDxLibなら
SetAsyncなんとか


使うのが大変でしたが、threadが出てきたおかげで
mutex/CritiacalSextionや状態変数などの恩恵を
受けられるようになってる


ラムダ式とは、関数オブジェクトである。
関数と違うの？関数っちゃ関数です。
関数っちゃ
